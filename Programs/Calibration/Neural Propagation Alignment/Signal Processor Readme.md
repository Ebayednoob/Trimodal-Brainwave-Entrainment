# Signal Processor GUI

## Overview

The Signal Processor GUI is a Python application that allows users to generate various input waveforms, apply non-linear transformations (simulating neural network activation functions) to these waveforms, and visualize the input signal, the transformed output signal, and a frequency domain representation of the input. It provides an interactive way to understand the effects of different signal parameters and non-linear functions.

## Features

* **Interactive GUI:** Built with Tkinter for a user-friendly experience.
* **Signal Generation:**
    * Choose from Sine, Square, or Sawtooth waveforms.
    * Adjust Amplitude (Voltage), Frequency (Hz), Duration (ms), and Phase Angle (degrees).
    * Control Duty Cycle for Square waves.
* **Non-linear Transformation:**
    * Apply one of several common neural network activation functions to the input signal:
        * ReLU (Rectified Linear Unit)
        * Sigmoid
        * Tanh (Hyperbolic Tangent)
        * Swish
        * GELU (Gaussian Error Linear Unit)
* **Multiple Visualizations:**
    * **Input Signal Plot:** Displays the generated time-domain waveform.
    * **Input Phase Plot:** A polar plot showing the phase of the input signal as an ellipse.
    * **Output Signal Plot:** Displays the time-domain waveform after applying the selected activation function.
    * **Output Phase Plot:** A polar plot (currently a placeholder) indicating a reference phase for the output.
    * **FFT Polar Plot:** Displays the magnitude and phase of the frequency components of the *input signal* using a Fast Fourier Transform (FFT), presented on a polar axis. This serves as an illustrative placeholder for a more complex Nonlinear Fourier Transform (NFT) concept.

## How it Works

1.  **Signal Generation:**
    * The user selects a waveform type and adjusts parameters like amplitude, frequency, duration, and phase.
    * **Sine Wave:** Generated using the standard sine function: `amplitude * sin(2 * pi * frequency * t + phase)`.
    * **Square Wave:** Generated by comparing the time within a period to the duty cycle. The phase is implemented as a time shift.
    * **Sawtooth Wave:** Generated with a linearly increasing ramp that resets each period. The phase is implemented as a time shift.

2.  **Non-linear Activation Functions:**
    These functions introduce non-linearity, which is a core concept in neural networks, allowing them to model complex relationships. The script implements the following:
    * **ReLU (Rectified Linear Unit):**
        * Formula: `output = max(0, input)`
        * Effect: Outputs the input directly if it's positive, otherwise, it outputs zero. It's simple and computationally efficient.
    * **Sigmoid:**
        * Formula: `output = 1 / (1 + exp(-input))`
        * Effect: Squashes the input values into a range between 0 and 1. Often used for binary classification output layers.
    * **Tanh (Hyperbolic Tangent):**
        * Formula: `output = tanh(input)` which is `(exp(input) - exp(-input)) / (exp(input) + exp(-input))`
        * Effect: Squashes input values into a range between -1 and 1. It's zero-centered, which can be advantageous over Sigmoid in some cases.
    * **Swish:**
        * Formula: `output = input * sigmoid(beta * input)` (where `beta` is a constant, typically 1)
        * Effect: A smooth, non-monotonic function that often performs as well or better than ReLU on deeper models.
    * **GELU (Gaussian Error Linear Unit):**
        * Formula (approximation): `output = 0.5 * input * (1 + tanh(sqrt(2 / pi) * (input + 0.044715 * input^3)))`
        * Effect: Weights inputs by their value, rather than gating inputs by their sign as in ReLU. It's used in models like BERT and GPT.

3.  **FFT Polar Plot (NFT Placeholder):**
    * The script calculates the Fast Fourier Transform (FFT) of the generated *input signal*.
    * The FFT decomposes the signal into its constituent frequencies, providing the magnitude (strength) and phase (offset) of each frequency component.
    * These magnitudes and phases are then plotted on a polar graph, where the angle represents the phase of the frequency component and the radial distance represents its magnitude.
    * This serves as a visual representation of the input signal's frequency content. While titled "FFT Polar Plot" in the latest GUI version, it's a placeholder for the more complex concept of a Nonlinear Fourier Transform (NFT) which is relevant in fields like nonlinear optics but requires specialized algorithms beyond a standard FFT.

## Requirements

* Python 3.x
* Tkinter (usually included with standard Python installations)
* NumPy: `pip install numpy`
* Matplotlib: `pip install matplotlib`

## How to Run

1.  Save the script as a Python file (e.g., `signal_processor_gui.py`).
2.  Open a terminal or command prompt.
3.  Navigate to the directory where you saved the file.
4.  Run the script using the command: `python signal_processor_gui.py`
5.  The GUI window will appear. Adjust the controls in the "Signal Generator Controls" panel and select an algorithm from the "Modification Algorithm" panel. Click "Generate & Update Signals" to see the plots refresh.

## GUI Components

* **Plot Area (Top Two Rows):**
    * **Row 1:** Input Signal (time vs. amplitude) and Input Phase (polar ellipse).
    * **Row 2:** Output Signal (time vs. transformed value), Output Phase (polar ellipse placeholder), and FFT Polar Plot (frequency component magnitude vs. phase).
* **Signal Generator Controls (Bottom Panel):**
    * **Waveform Type:** Dropdown (Sine, Square, Sawtooth).
    * **Duty Cycle:** Slider and entry (for Square wave).
    * **Amplitude (V):** Slider and entry.
    * **Frequency (Hz):** Slider and entry.
    * **Duration (ms):** Slider and entry.
    * **Phase (deg):** Slider and entry.
* **Modification Algorithm (Bottom Panel):**
    * **Select Algorithm:** Dropdown for choosing the activation function.
    * **Generate & Update Signals Button:** Applies current settings and refreshes all plots.

## Future Considerations / NFT
The "Nonlinear Fourier Transform" (NFT) is a sophisticated mathematical tool, particularly used in analyzing systems governed by nonlinear equations (like the Nonlinear Schr√∂dinger Equation in optical fiber communications). Unlike the standard FFT, which works for linear systems, the NFT is designed to handle nonlinearities directly. Implementing a true NFT is a complex task and would typically involve:
* Solving an associated scattering problem (direct scattering transform).
* Analyzing the resulting spectral data (eigenvalues, spectral coefficients).
* Potentially performing an inverse scattering transform to reconstruct a signal.

The current "FFT Polar Plot" in this GUI provides a basic frequency domain view of the *input* signal using linear FFT techniques and is not a true NFT.
